


import xlwings as xw

wb = xw.Book(r'C:\path\to\your_file.xlsm')

for sheet in wb.sheets:
    # 获取 print area
    print_area = sheet.api.PageSetup.PrintArea  # "A1:F20"
    if not print_area:
        continue

    # 解析 print area
    start_cell, end_cell = print_area.split(':')
    start_row = sheet.range(start_cell).row
    start_col = sheet.range(start_cell).column
    end_row = sheet.range(end_cell).row
    end_col = sheet.range(end_cell).column

    # sheet 最大行列
    max_row = sheet.cells.last_cell.row
    max_col = sheet.cells.last_cell.column

    # 1️⃣ 删除 print area 下方多余行
    if end_row < max_row:
        sheet.range(f"{end_row+1}:{max_row}").api.Delete()

    # 2️⃣ 清除 print area 之外的边框
    # 遍历整个 sheet
    for row in range(1, max_row + 1):
        for col in range(1, max_col + 1):
            # 判断是否在 print area 内
            if start_row <= row <= end_row and start_col <= col <= end_col:
                continue  # 保留 print area 内的边框
            cell = sheet.range((row, col))
            cell.api.Borders.LineStyle = -4142  # xlLineStyleNone

    # 3️⃣ 第六行到 print area 最下方，指定列右边加线
    n_col = 4  # 假设 N 列是第 4 列
    y_col = 7  # 假设 Y 列是第 7 列
    for row in range(6, end_row + 1):
        for col in [n_col, y_col]:
            sheet.range((row, col)).api.Borders(10).LineStyle = 1  # xlEdgeRight

# 保存
wb.save()
wb.close()





import xlwings as xw

# 打开 Excel（保留宏）
wb = xw.Book(r'C:\path\to\your_file.xlsm')

for sheet in wb.sheets:
    # 读取 print area
    print_area = sheet.api.PageSetup.PrintArea  # 返回类似 "A1:F20"
    if not print_area:
        continue
    
    # 解析 print_area
    start_cell, end_cell = print_area.split(':')
    start_row = sheet.range(start_cell).row
    start_col = sheet.range(start_cell).column
    end_row = sheet.range(end_cell).row
    end_col = sheet.range(end_cell).column

    # 1. 删除 print area 下面所有多余行
    last_row = sheet.cells.last_cell.row
    if end_row < last_row:
        sheet.range(f"{end_row+1}:{last_row}").api.Delete()

    # 2. 删除 print area 外的单元格线（Borders）
    # 遍历整个 sheet 清空边框
    used_range = sheet.used_range
    for cell in used_range:
        cell.api.Borders.LineStyle = -4142  # xlLineStyleNone

    # 3. 第六行到 print area 下面，n列和y列右侧加线
    n_col = 4  # 假设 N 列是第4列
    y_col = 7  # 假设 Y 列是第7列
    for row in range(6, end_row+1):
        sheet.range((row, n_col)).api.Borders(10).LineStyle = 1  # xlEdgeRight
        sheet.range((row, y_col)).api.Borders(10).LineStyle = 1  # xlEdgeRight

# 保存
wb.save()
wb.close()






import xlwings as xw

def clear_border_outside_print_area(path):
    wb = xw.Book(path)
    ws = wb.sheets["Sheet1"]

    # 1. 取打印区域（如 "$A$1:$Y$632"）
    print_area = ws.api.PageSetup.PrintArea
    if not print_area:
        raise RuntimeError("未设置打印区域")

    # 去掉$
    area = print_area.replace("$", "")
    rng = ws.range(area)

    # 2. 先记下打印区域的行列范围
    used = ws.used_range
    used_first_row = used.row
    used_last_row = used.last_cell.row
    used_first_col = used.column
    used_last_col = used.last_cell.column

    rng_first_row = rng.row
    rng_last_row = rng.last_cell.row
    rng_first_col = rng.column
    rng_last_col = rng.last_cell.column

    # 3. 分四块清边框：上、下、左、右，只清范围外
    # 上方区域
    if used_first_row < rng_first_row:
        ws.range(
            (used_first_row, used_first_col),
            (rng_first_row - 1, used_last_col)
        ).api.Borders.LineStyle = 0  # xlLineStyleNone

    # 下方区域
    if rng_last_row < used_last_row:
        ws.range(
            (rng_last_row + 1, used_first_col),
            (used_last_row, used_last_col)
        ).api.Borders.LineStyle = 0

    # 左侧区域（与打印区域行上下对齐）
    if used_first_col < rng_first_col:
        ws.range(
            (rng_first_row, used_first_col),
            (rng_last_row, rng_first_col - 1)
        ).api.Borders.LineStyle = 0

    # 右侧区域
    if rng_last_col < used_last_col:
        ws.range(
            (rng_first_row, rng_last_col + 1),
            (rng_last_row, used_last_col)
        ).api.Borders.LineStyle = 0

    # 4. 删除打印区域下方多余行（你已经有逻辑的话，这段可以保持不变）
    if used_last_row > rng_last_row:
        ws.range(f"{rng_last_row+1}:{used_last_row}").delete()

    wb.save()
    if len(wb.app.books) == 1:
        wb.app.quit()
    else:
        wb.close()





import xlwings as xw

def format_by_print_area(path):
    wb = xw.Book(path)
    ws = wb.sheets["Sheet1"]

    # 取打印区域（形如 "$A$1:$Y$632"）
    print_area = ws.api.PageSetup.PrintArea
    if not print_area:
        raise RuntimeError("未设置打印区域")

    # 去掉美元符号
    area = print_area.replace("$", "")
    rng = ws.range(area)

    # 1. 全表清边框
    ws.used_range.api.Borders.LineStyle = 0  # xlLineStyleNone

    # 2. 打印区域加细边框
    rng.api.Borders.LineStyle = 1   # xlContinuous
    rng.api.Borders.Weight = 2      # xlThin

    # 3. 删除打印区域下方行
    last_row = ws.used_range.last_cell.row
    bottom_row = rng.last_cell.row
    if last_row > bottom_row:
        ws.range(f"{bottom_row+1}:{last_row}").delete()

    wb.save()
    if len(wb.app.books) == 1:
        wb.app.quit()
    else:
        wb.close()


from openpyxl import load_workbook
from openpyxl.styles import Border, Side

def process_by_print_area(path, sheet_name):
    wb = load_workbook(path)
    ws = wb[sheet_name]

    # 1. 读取打印区域，比如 "A1:AD60"
    print_area = ws.print_area
    if not print_area:
        raise ValueError("当前工作表没有设置打印区域，请先在 Excel 里设好打印区域（就是蓝色粗框）")

    # openpyxl 把打印区域存成类似 ('A1:AD60',) 的元组
    area = list(print_area)[0]
    start, end = area.split(":")
    from openpyxl.utils import column_index_from_string, get_column_letter

    def parse_addr(addr):
        # 如 "AD60" -> (列号, 行号)
        col_str = "".join([c for c in addr if c.isalpha()])
        row_str = "".join([c for c in addr if c.isdigit()])
        return column_index_from_string(col_str), int(row_str)

    min_col, min_row = parse_addr(start)
    max_col, max_row = parse_addr(end)

    # 2. 打印范围内统一设置细边框（让蓝框内格子都连成一体）
    thin = Border(
        left=Side(style="thin"),
        right=Side(style="thin"),
        top=Side(style="thin"),
        bottom=Side(style="thin")
    )
    for row in ws.iter_rows(min_row=min_row, max_row=max_row,
                            min_col=min_col, max_col=max_col):
        for cell in row:
            cell.border = thin

    # 3. 清除打印范围外所有边框（包括上、下、左、右）
    for row in ws.iter_rows():
        for cell in row:
            if (cell.row < min_row or cell.row > max_row or
                cell.column < min_col or cell.column > max_col):
                cell.border = Border()   # 清空边框

    # 4. 删除打印范围下面多余的行（整行删除）
    #   从最后一行往上删，避免行号变化
    last_row = ws.max_row
    for r in range(last_row, max_row, -1):
        ws.delete_rows(r)

    wb.save(path)

# 使用示例
if __name__ == "__main__":
    process_by_print_area("你的表.xlsx", "Sheet1")



import re

def strip_comments(sql: str) -> str:
    sql = re.sub(r'/\*.*?\*/', '', sql, flags=re.S)
    sql = re.sub(r'--.*?(?=$)', '', sql)
    return sql.strip()

def extract_sql_php(line: str) -> str:
    # 去掉前缀：[pa 15326 0] - 或其他
    sql = re.sub(r'^\[.*?\]\s*-?\s*', '', line)
    sql = strip_comments(sql)
    return sql

def extract_sql_java(lines: list[str]) -> list[str]:
    cleaned = []
    i = 0
    while i < len(lines):
        line = lines[i].strip()

        if line.startswith("Preparing:"):
            sql = line.replace("Preparing:", "").strip()
            sql = strip_comments(sql)
            sql = sql.replace('\n', ' ')

            params = []
            # 下一行如果是参数
            if i + 1 < len(lines) and "Parameters:" in lines[i+1]:
                p = re.sub(r'^.*?Parameters:\s*', '', lines[i+1]).strip()
                arr = p.split(',')
                for a in arr:
                    val = a.rsplit('(', 1)[0].strip()
                    params.append(val)
                i += 1

            for p in params:
                sql = sql.replace('?', f"'{p}'", 1)

            cleaned.append(sql)

        i += 1
    return cleaned

def compare_sql(list1, list2):
    # 按顺序比较（你要求的）
    diffs = []
    for i in range(max(len(list1), len(list2))):
        v1 = list1[i] if i < len(list1) else ""
        v2 = list2[i] if i < len(list2) else ""
        if v1 != v2:
            diffs.append((i + 1, v1, v2))
    return diffs

# ---------------- 入口函数 ----------------

def process_files(php_file, java_file, out_php, out_java):
    php_sqls = [extract_sql_php(l) for l in open(php_file, encoding="utf8")]
    java_sqls = extract_sql_java(open(java_file, encoding="utf8").readlines())

    # 输出清洗后的文件
    open(out_php, "w", encoding="utf8").write("\n".join(php_sqls))
    open(out_java, "w", encoding="utf8").write("\n".join(java_sqls))

    diffs = compare_sql(php_sqls, java_sqls)
    return diffs